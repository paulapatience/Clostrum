\chapter{Evaluation environment}

\section{Mixin class}

\Defclass {evaluation-environment-mixin}

This class should be used by client code to create a client-specific
evaluation environment class (say \texttt{evaluation-environment})
that has a subclass of this mixin class and a subclass of
\texttt{run-time-environment} as superclasses \emph{in that order}.
It is important that this mixin class precede the run-time environment
class in the list of superclasses, so that the methods described in
this chapter (specialized to \texttt{evaluation-environment-mixin})
are more specific than the methods specialized to
\texttt{run-time-environment}.

\Definitarg {:parent}

This initialization argument must be provided and should be either
another evaluation environment, or a run-time environment.  In most
cases, it should be a run-time environment, i.e., an instance of the
class \texttt{run-time-environment}.

\Defgeneric {parent} {environment}

\Defmethod {parent} {(environment {\tt evaluation-environment-mixin})}

This generic function returns the environment object that was passed
as the \texttt{:parent} initialization argument when
\textit{environment} was created.

\section{Methods}

{\small\Defmethod {special-operator} {client (environment {\tt
      evaluation-environment-mixin}) \\ name}
}

This method first queries \textit{environment} to see whether
\textit{name} is defined as a special operator there.  If so, i.e., if
the definition there is non-\texttt{nil}, that definition is returned.
If the definition there is \texttt{nil}, then this method recursively
calls \texttt{special-operator} with the same \textit{client}
argument, a second argument resulting from calling \texttt{(parent}
\textit{environment}\texttt{)}, and the same \textit{name} argument.
The return value of the recursive call is then returned.

In a typical system, there are no provisions for adding new special
operators at compile time to be used only at compile time, so the
initial query would then return \texttt{nil}.  But we see no reason to
disallow the possibility of adding new special operators at compile
time in case some clients need such a feature.

{\small\Defmethod {fdefinition} {client (environment {\tt
      evaluation-environment-mixin}) \\ name}
}

This method first queries \textit{environment} to see whether
\textit{name} is defined as a function there.  If so, i.e., if the
definition there is non-\texttt{nil}, that definition is returned.  If
the definition there is \texttt{nil}, then this method recursively
calls \texttt{fdefinition} with the same \textit{client} argument, a
second argument resulting from calling \texttt{(parent}
\textit{environment}\texttt{)}, and the same \textit{name} argument.
The return value of the recursive call is then returned.

As a result of this behavior, if a function definition is made at
compile time (presumably by a call to \texttt{(setf fdefinition)} on
an instance of the client-specific \texttt{evaluation-environment}
class), then a subsequent call to \texttt{fdefinition} will return
that compile-time definition, effectively overriding a possible
definition by the same name in the run-time environment.

{\small\Defmethod {macro-function} {client (environment {\tt
      evaluation-environment-mixin}) \\ name}
}

This method first queries \textit{environment} to see whether
\textit{name} is defined as a macro function there.  If so, i.e., if
the definition there is non-\texttt{nil}, that definition is returned.
If the definition there is \texttt{nil}, then this method recursively
calls \texttt{macro-function} with the same \textit{client} argument,
a second argument resulting from calling \texttt{(parent}
\textit{environment}\texttt{)}, and the same \textit{name} argument.
The return value of the recursive call is then returned.

As a result of this behavior, if a macro definition is made at compile
time (presumably by a call to \texttt{(setf macro-function)} on an
instance of the client-specific \texttt{evaluation-environment}
class), then a subsequent call to \texttt{macro-function} will return
that compile-time definition, effectively overriding a possible
definition by the same name in the run-time environment.

{\small\Defmethod {compiler-macro-function} {client (environment {\tt
      evaluation-environment-mixin}) \\ name}
}

This method first queries \textit{environment} to see whether
\textit{name} is defined as a compiler macro function there.  If so,
i.e., if the definition there is non-\texttt{nil}, that definition is
returned.  If the definition there is \texttt{nil}, then this method
recursively calls \texttt{compiler-macro-function} with the same
\textit{client} argument, a second argument resulting from calling
\texttt{(parent} \textit{environment}\texttt{)}, and the same
\textit{name} argument.  The return value of the recursive call is
then returned.

As a result of this behavior, if a compiler-macro definition is made
at compile time (presumably by a call to \texttt{(setf
  compiler-macro-function)} on an instance of the client-specific
\texttt{evaluation-environment} class), then a subsequent call to
\texttt{compiler-macro-function} will return that compile-time
definition, effectively overriding a possible definition by the same
name in the run-time environment.

{\small\Defmethod {function-type} {client (environment {\tt
      evaluation-environment-mixin}) \\ name}
}

This method first executes \texttt{(call-next-method)}.  If the return
value of that call is non-\texttt{nil}, it is returned.  If the return
value of the call \texttt{(call-next-method)} is \texttt{nil}, then
this method recursively calls \texttt{function-type} with the same
\textit{client} argument, a second argument resulting from calling
\texttt{(parent} \textit{environment}\texttt{)}, and the same
\textit{symbol} argument.  The return value of the recursive
call is then returned.

As a result of this behavior, if a type proclamation is made at
compile time (presumably by a call to \texttt{(setf function-type)} on
an instance of the client-specific \texttt{evaluation-environment}
class), then a subsequent call to \texttt{function-type} will return
that type proclaimed at compile-time, effectively overriding a
possible type proclamaiton using the same name in the run-time
environment.

MORE METHODS HERE...
